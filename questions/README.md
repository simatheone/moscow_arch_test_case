## Вопросы:
1.	Что такое итераторы/генераторы/генераторные выражения, чем они отличаются и когда и как все это нужно использовать.

2.	Разница между `__init __()` и `__new__()`?

3.	Для чего используют нижние подчеркивания в именах классов?

---

## Ответы:
1. **Итератор** – это объект, который выполняет проход по элементам. Благодаря методу` __next__()` итератор возвращает следующий элемент, если такой есть, либо возвращает исключение StopIteration.

    **Генератор** – это подвид итератора, функция, которая генерирует значения. Генератор хранит в памяти не элементы, а внутреннее состояние для вычисления очередного элемента. На каждом шаге можно вычислить только следующий элемент, но не предыдущий. Перебрать генератор в цикле можно только один раз.

    **Все генераторы – это итераторы, но не все итераторы – это генераторы.**

    **Генераторное выражение** – упрощенный синтаксис для создания генератора. Синтаксис создания такого выражения похож на синтаксис `list comprehension`, только вместо квадратных скобок используются круглые.

    Итераторы используются для перебора каких-либо коллекций. Также итераторы используются, если мы хотим обойти элементы внутри объекта нашего собственного класса. Можем написать свой итератор, реализовав в нем методы __iter__() и __next__(), и логику обхода данных.

    Генераторы используются в случаях, когда мы не хотим загружать в память огромные объемы данных. Например, при чтении больших файлов, или чтение и обработка страниц при веб парсинге. Мы считываем 1 строку (в случае для файла) или одну страницу (в случае с парсингом), обрабатываем информацию, двигаемся дальше.

    Также с помощью генераторов можно создавать бесконечные последовательности.

2. Метод `__new__()` отвечает за создание экземпляра класса и возвращает новый созданный объект. Метод `__init__()` вызывается после вызова метода `__new__()` и отвечает за инициализацию атрибутов экземпляра.

    С помощью переопределения метода `__new__()` можно, например, управлять поведением экземплера при его создании. Например, реализовать паттерн Singleton (класс, для которого можно создать 1 и только 1 экземпляр объекта).

    Пример:

```python
class Point:
    def __new__(cls, *args, **kwargs):
        # если не вернуть адрес нового созданного объекта
        # то до инициализации атрибутов дело не дойдет
        pass

    def __init__(self, x=0, y=0):
        print(f'Вызов __init__ для: {self}')
        self.x = x
        self.y = y


point = Point(1, 10)
print(point)
>>> Вызов __new__ для: <class '__main__.Point'>
>>> None          # (без возвращения адреса нового созданного объекта)
```

```python
class Point:
    def __new__(cls, *args, **kwargs):
        print(f'Вызов __new__ для: {cls}')
        return super().__new__(cls)         # возвращаем адреса нового созданного объекта

    def __init__(self, x=0, y=0):
        print(f'Вызов __init__ для: {self}')
        self.x = x
        self.y = y


point = Point(1, 10)
print(point)
>>> Вызов __new__ для: <class '__main__.Point'>
>>> Вызов __init__ для: <__main__.Point object at 0x7fc170837e50>
>>> <__main__.Point object at 0x7fc170837e50>
```


3. Для того чтобы показать, что данный класс является приватным/защищенным, то есть не предназначен для публичного пользования.

    Одиночный знак подчеркивания перед именем класса может использоваться в нескольких вариантах:
   - указать, что данный класс устарел и его не следует использовать.
   - указать, что данный класс предназначен только для наследования, как родительский класс, от которого наследуются другие классы, и напрямую не используется.
   - указать, что данный класс не предназначен для использования вне модуля. Если попытаться импортировать такой класс через wildcard (from module import *), то он не будет проимпортирован.


Пример:
```python
class Base:
    pass


class _MidClass(Base):
    pass


class NewClass(_MidClass):
    pass
```

_MidClass используется как родительский класс для класса NewClass, но не предназначен для непосредственного использования.
